"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3177],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),s=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=s(n),m=a,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return n?i.createElement(g,o(o({ref:t},p),{},{components:n})):i.createElement(g,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<r;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},70863:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>s});var i=n(87462),a=(n(67294),n(3905));const r={sidebar_position:99},o="KCLVM Architecture",c={unversionedId:"develop/design/kclvm",id:"develop/design/kclvm",title:"KCLVM Architecture",description:"The implementation of KCLVM compiler is driven by many specifications (mainly including KCL language specification, KCL multilingual integration specification, and KCL OpenAPI specification). Besides, KCL is a compiled language, maintaining the same three-stage architecture as the regular programming language compiler, and using LLVM-IR as the intermediate link between KCL and Native/WASM code.",source:"@site/docs/develop/design/kclvm.md",sourceDirName:"develop/design",slug:"/develop/design/kclvm",permalink:"/docs/develop/design/kclvm",editUrl:"https://github.com/KusionStack/kusionstack.io/blob/main/docs/develop/design/kclvm.md",tags:[],version:"current",lastUpdatedBy:"dependabot[bot]",lastUpdatedAt:1672718015,formattedLastUpdatedAt:"1/3/2023",sidebarPosition:99,frontMatter:{sidebar_position:99},sidebar:"develop",previous:{title:"Konfig Dir Struct",permalink:"/docs/develop/design/konfig"},next:{title:"KEP",permalink:"/docs/develop/kep"}},l={},s=[],p={toc:s};function d(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"kclvm-architecture"},"KCLVM Architecture"),(0,a.kt)("p",null,(0,a.kt)("img",{loading:"lazy",src:n(11036).Z,width:"1876",height:"674"})),(0,a.kt)("p",null,"The implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"KCLVM")," compiler is driven by many specifications (mainly including KCL language specification, KCL multilingual integration specification, and KCL OpenAPI specification). Besides, KCL is a compiled language, maintaining the same three-stage architecture as the regular programming language compiler, and using LLVM-IR as the intermediate link between KCL and Native/WASM code."),(0,a.kt)("p",null,"KCL has the following three core stages:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Translation KCL code to LLVM-IR. By parsing the KCL code and traversing the KCL AST, the corresponding LLVM-IR code is generated according to the KCL language specification."),(0,a.kt)("li",{parentName:"ul"},"KCL runtime library integration. KCL runtime library provides runtime KCL value calculation, memory, context management, built-in library and plug-in library support."),(0,a.kt)("li",{parentName:"ul"},"User mode and system mode code linking and execution. Link user mode code and system mode code into a dynamic link library, and finally execute the compiled KCL code through the unified runner module.")),(0,a.kt)("p",null,"In addition, KCL provides enhanced support for the semantic resolver and plugins:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Resolver",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Static type inference and checking"),". Type inference and checking can be performed at compile time to avoid the overhead of type check at runtime, which can be used as the basis for IDE plug-in and semantic API support (such as schema model query, dependency analysis, etc.)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Configuration graph unification"),". By building and merging the configuration data dependency graph during the compilation process, the final configuration data can be obtained through only a few calculations during the runtime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Semantic dependency graph"),". Through the built-in semantic dependency graph, KCL can complete the dependency analysis when the configuration changes, which can improve the end-to-end compilation performance by performing incremental compilation."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Schema-centric OOP"),". KCL language only retains the syntax of single inheritance, but the schema can mix and reuse the same code fragments through the features such as ",(0,a.kt)("inlineCode",{parentName:"li"},"mixin")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"protocol"),"."))),(0,a.kt)("li",{parentName:"ul"},"Plugin. We can use Python/Go to write plugin libraries, which mainly include some domain capabilities, such as accessing networks or databases.")))}d.isMDXComponent=!0},11036:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/kcl-tech-arch-80e0de63d5a17ac656650bf408117ef4.png"}}]);